# Web Workers + Perturbation Theory: Architecture Discussion

**Date:** 2025-11-16
**Status:** Research & Design Phase
**Context:** Deep dive into progressive rendering architecture for 30-minute deep zoom renders

---

## Executive Summary

This document captures our architectural exploration of implementing Web Workers for progressive rendering in Fractal Wonder, with particular focus on perturbation theory requirements for deep zoom (10^100+) rendering.

**Key findings:**
- Progressive rendering is essential (30-minute renders make it non-negotiable)
- Manual Web Workers required (wasm-bindgen-rayon blocks until completion)
- Perturbation theory requires adaptive quadtree subdivision (not fixed tile grid)
- Architecture complexity increases significantly with perturbation theory

**Critical decision pending:** MVP without perturbation vs. designing for perturbation from start

---

We want our app to achieve the following things:

- user interaction should always be responsive
- we want to use as much CPU power as possible, across multiple cores
- the workers ONLY compute data per pixel. The main thread will colorise and put on canvas
- panning and zooming should immediately stop computation and prevent runaway compute threads
- a strong candidate for the multi threading mechanism is wasm-bindgen-rayon + SharedArrayBuffer
- rendering **must** be progressive: the user should see progress in some form while the fractal is rendering.
- we should not use tiles.par_iter().map(compute).collect() because that is incompatible with progressive rendering
- instead tile computation should write directly to the shared buffer, e.g. something like:

    ```txt
    tiles.par_iter().for_each(|tile| {
        render_tile_into_shared_buffer(tile);
        mark_tile_ready(tile.index);
    });
    ```

For the fractal computation itself:

- we want to support EXTREME zoom levels (e.g. 10^100)
- we want to implement perturbation theory in the future
- for perturbation theory we will need an adaptive quad tree tiling algorithm:
  - initially we compute one reference orbit for the viewport (likely its center)
  - we compute the four corner points as well
  - if the results are unstable, we subdivide the tile and recursively apply the same algorithm
  - once we have stable reference orbits, we us perturbation theory to compute the tile's pixels
- we already support arbitrary precision (used for reference orbit computation)

RESEARCH QUESTIONS:

- RQ-1: Using perturbation theory, at extreme zoom levels, can we use 64 bit precision for all computation apart from
  the reference orbits?
- RQ-2: Could we later swap out (or add to) the CPU web workers and use GPU instead for all computation apart from
  reference orbits?
- RQ-3: How do we quickly stop all compute when the user wants to interact with the app?
- RQ-4: I had issues in the past where workers could not run because the WASM had a dependency on the DOM via Leptos
  and hydrate(). Is this an issue with wasm-bindgen-rayon? Do we need multiple entry points (worker / main), multiple
  crates, or something else?
- if we need multiple crates or WASM files, can we still use `trunk serve` or implement another way to watch files
  and rebuild on the fly during development?
- RQ-6: where should the reference orbits be computed? On the worker threads? Or on the main thread?
- RQ-7: Describe a high level algorithm that implements the above

FURTHER NOTES:

- main thread waits for workers to be ready (if necessary) and can display a loading indicator while it's waiting
- WebAssembly 3.0 was released September 2025 (after knowledge cutoff). key features:
  - 64-bit address space
  - Multiple memories
  - Garbage collection
  - Typed references
  - Tail calls
  - Exception handling
  - Relaxed vector instructions
- perturbation theory: Multiple reference orbits required when a single reference orbit no longer yields numerically
  stable perturbations. When Multiple References Are Needed:
  1. Large deviation from reference pixel
    - Perturbation assumes pixel orbit stays close to reference
    - Spatial distance too large â†’ perturbation series loses accurac
  2. Deep zooms with high magnification
    - Numerical precision becomes fragile
    - Round-off error accumulates
    - Subdividing into tiles with individual references restores stabilit
  3. Regions where orbit derivatives blow up
    - Near minibrots, filaments, sensitive dynamical areas
    - Correction terms amplify rapidly
    - Adjacent pixels diverge from shared reference too fas
  4. Long escape times
    - Many iterations before divergence
    - Small perturbations magnified
    - Multiple references reduce accumulated error

